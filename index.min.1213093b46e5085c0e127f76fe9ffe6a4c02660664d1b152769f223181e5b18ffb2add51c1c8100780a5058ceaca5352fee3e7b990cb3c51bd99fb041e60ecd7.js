var suggestions=document.getElementById('suggestions');var userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(e){if(e.keyCode===191){e.preventDefault();userinput.focus();}
if(e.keyCode===27){userinput.blur();suggestions.classList.add('d-none');}}
document.addEventListener('click',function(event){var isClickInsideElement=suggestions.contains(event.target);if(!isClickInsideElement){suggestions.classList.add('d-none');}});document.addEventListener('keydown',suggestionFocus);function suggestionFocus(e){const focusableSuggestions=suggestions.querySelectorAll('a');const focusable=[...focusableSuggestions];const index=focusable.indexOf(document.activeElement);let nextIndex=0;if(e.keyCode===38){e.preventDefault();nextIndex=index>0?index-1:0;focusableSuggestions[nextIndex].focus();}
else if(e.keyCode===40){e.preventDefault();nextIndex=index+1<focusable.length?index+1:index;focusableSuggestions[nextIndex].focus();}}
(function(){var index=new FlexSearch({preset:'score',cache:true,doc:{id:'id',field:['title','description','content',],store:['href','title','description',],},});var docs=[{id:0,href:"https://project-wormhole.github.io/docs/introduction/",title:"Introduction",description:"Wormhole is a Open Source project aimed to provide Open Standard allows people on different apps to communicate with each other by secure, fast, and reliable protocol.",content:"\u003ch2 id=\"how-does-it-work\"\u003eHow does it work?\u003c/h2\u003e\n\u003ch3 id=\"intra-and-inter-messaging\"\u003eIntra and Inter Messaging\u003c/h3\u003e\n\u003cp\u003eOnly inter-app messages are go through wormhole server, intra messages will have no difference. We provide client SDKs which help you to integrate with least effort.\u003c/p\u003e\n\u003ch3 id=\"messaging\"\u003eMessaging\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eRestful APIs is provided to register user, create chats and complete with E2EE etc.\u003c/li\u003e\n\u003cli\u003eWebsocket provides efficient messaging interface that avoids the overheads of negotiation and reduce the latency.\u003c/li\u003e\n\u003cli\u003eWebRTC is introduced to secure real-time voice and video calls over the web.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"security\"\u003eSecurity\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDouble Ratchet algorithm is used to exchange encrypted messages based on a shared secret key\u003c/li\u003e\n\u003cli\u003eX3DH key agreement protoco is integrated and used as the Double Ratchet\u0026rsquo;s initial root key\u003c/li\u003e\n\u003cli\u003eSesame algorithm for managing message encryption sessions in an asynchronous and multi-device setting\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"privacy\"\u003ePrivacy\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eProfile and Picture names and pictures let people know who is messaging them. Wormhole service has no knowledge of them since they are end-to-end encrypted\u003c/li\u003e\n\u003cli\u003eMessages are protected by E2EE that wormhole and third party does not have a means to decrypt them. Only senders and intended recipients can read the messages.\u003c/li\u003e\n\u003cli\u003eMessage Requests give you the option to block, delete, and accept messages from somebody that trying to get in touch with you.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"open-source-open-standard\"\u003eOpen source, open standard\u003c/h3\u003e\n\u003cp\u003eWormhole is based on Signal project and plan to provide\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOpen Source\n\u003cul\u003e\n\u003cli\u003eClient SDKs ( Apache License)\u003c/li\u003e\n\u003cli\u003eClient reference implementation ( Android, iOS)\u003c/li\u003e\n\u003cli\u003eApplication Server\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eOpen Standard\n\u003cul\u003e\n\u003cli\u003eInter-service communication protocol\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eStandalong service\n\u003cul\u003e\n\u003cli\u003eProduction grad inter-service messaging service\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"},{id:1,href:"https://project-wormhole.github.io/docs/specification/",title:"Specification",description:"Specification of Wormhole project",content:"\u003cp\u003eWormhole server APIs are forked from \u003ca href=\"https://github.com/signalapp/Signal-Server\"\u003eSignal Server\u003c/a\u003e. Wormhole modified various features to support cross App communication.\u003c/p\u003e\n\u003ch2 id=\"architecture\"\u003eArchitecture\u003c/h2\u003e\n\u003cp\u003eAll apps send messages to their original IM server if their client tries to communicate with users in the same app. However, if clients try to send messages to another App, the messages will be delivered to the Wormhole server and then passed to the intended recipients via Wormhole SDKs. All messages are encrypted on the client side to make sure the Wormhole can’t see its content. Also, Wormhole will only store non private data to protect the user and partner’s privacy.\u003c/p\u003e\n\u003ch2 id=\"wormhole-server-apis\"\u003eWormhole Server APIs\u003c/h2\u003e\n\u003ch3 id=\"registration\"\u003eRegistration\u003c/h3\u003e\n\u003ch4 id=\"request-a-verification-code\"\u003eRequest a verification code\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003eGET /v1/accounts/sms/code/{number}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe client requests an SMS verification code for the client\u0026rsquo;s PSTN number.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003enumber\u003c/code\u003e is the client\u0026rsquo;s PSTN number.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eReturns\u003c/strong\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e200\u003c/code\u003e request was processed successfully.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e400\u003c/code\u003e badly formatted \u003ccode\u003enumber\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e415\u003c/code\u003e invalid \u003ccode\u003etransport\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e413\u003c/code\u003e rate limit exceeded. Too many requests.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"confirm-a-verification-code\"\u003eConfirm a verification code\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003ePUT /v1/acccounts/code/{verification_code}\nAuthorization: Basic {basic_auth}\nX-PKG-NAME: {package_name}\nX-PKG-TOKEN: {package_token}\n\n{\n  \u0026quot;signalingKey\u0026quot; : \u0026quot;{base64_encoded_52_byte_key}\u0026quot;,\n  \u0026quot;supportsSms\u0026quot; : false,\n  \u0026quot;registrationId\u0026quot; : \u0026quot;{14-bit number}\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe client submits the verification code it received via voice or SMS to the server for confirmation.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003everification_code\u003c/code\u003e is the code it received via voice or SMS, numeric only.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebasic_auth\u003c/code\u003e are the authorization credentials the client would like to create.  These are in the form of \u003ccode\u003eBase64({number}:{password})\u003c/code\u003e, where \u003ccode\u003enumber\u003c/code\u003e is the client\u0026rsquo;s verified PSTN number and \u003ccode\u003epassword\u003c/code\u003e is a randomly generated 16 byte ASCII string.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epackage_name\u003c/code\u003e is the App\u0026rsquo;s package used to distinguish between apps.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epackage_token\u003c/code\u003e is the token provided by \u003ccode\u003eWormhole\u003c/code\u003e after registered to \u003ccode\u003eWormhole\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esignalingKey\u003c/code\u003e is a randomly generated 32 byte AES key and a 20 byte HMAC-SHA1 MAC key, concatenated together and Base64 encoded.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esupportsSms\u003c/code\u003e indicates whether a client supports SMS as a transport.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eregistrationId\u003c/code\u003e is a 14 bit integer that\u0026rsquo;s randomly generated at client install time. This will be used for clients to detect whether an app has reinstalled and lost their session state.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eReturns\u003c/strong\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e200\u003c/code\u003e account successfully verified.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e401\u003c/code\u003e badly formatted \u003ccode\u003ebasic_auth\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e403\u003c/code\u003e incorrect \u003ccode\u003everification_code\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e413\u003c/code\u003e rate limit exceeded.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e417\u003c/code\u003e number already registered.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"registering-an-apn-or-gcm-id\"\u003eRegistering an APN or GCM id\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003ePUT /v1/accounts/{push_channel}/\nAuthorization: Basic {basic_auth}\nX-PKG-NAME: {package_name}\nX-PKG-TOKEN: {package_token}\n\n{\n  \u0026quot;apnRegistrationId\u0026quot;: \u0026quot;{apn_registration_id}\u0026quot;,\n  \u0026quot;gcmRegistrationId\u0026quot;: \u0026quot;{gcm_registration_id}\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe client submits its APN or GCM push registration ID.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003epush_channel\u003c/code\u003e is the string \u003ccode\u003eapn\u003c/code\u003e or \u003ccode\u003egms\u003c/code\u003e, depending on device.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebasic_auth\u003c/code\u003e is the client\u0026rsquo;s authorization credentials (see above).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egcm_registration_id\u003c/code\u003e or \u003ccode\u003eapn_registration_id\u003c/code\u003e is the client\u0026rsquo;s registration ID.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eReturns\u003c/strong\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e200\u003c/code\u003e request succeeded.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e401\u003c/code\u003e invalid authentication credentials.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e415\u003c/code\u003e badly formatted JSON.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eTo unregister from the server, send the same request with method \u003ccode\u003eDELETE\u003c/code\u003e.\u003c/p\u003e\n\u003ch4 id=\"registering-prekeys\"\u003eRegistering prekeys\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003ePUT /v2/keys/ \nAuthorization: Basic {basic_auth}\nX-PKG-NAME: {package_name}\nX-PKG-TOKEN: {package_token}\n\n{\n  lastResortKey : {\n                   keyId: 0xFFFFFF\n                   publicKey: \u0026quot;{public_key}\u0026quot;\n                   identityKey: \u0026quot;{identity_key}\u0026quot;\n                  },\n   keys: [\n         {\n          keyId: {key_id},\n          publicKey: \u0026quot;{public_key}\u0026quot;,\n          identityKey: \u0026quot;{identity_key}\u0026quot;\n         },\n         ...]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e\u003ccode\u003epublic_key\u003c/code\u003e is a randomly generated Curve25519 public key with a leading byte of \u003ccode\u003e0x05\u003c/code\u003e to indicate its type. This is a total of 33 bytes, base64 encoded without padding (no ==).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eidentity_key\u003c/code\u003e is a Curve25519 public key with a leading byte of \u003ccode\u003e0x05\u003c/code\u003e to indicate its type. This is a total of 33 bytes, base64 encoded without padding (no ==).  Each client should have a single identity key generated at install time.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekey_id\u003c/code\u003e each prekey has a unique 24bit identifier.  The last resort key is always 0xFFFFFF.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eReturns\u003c/strong\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e200\u003c/code\u003e request succeeded.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e401\u003c/code\u003e invalid authentication credentials.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e415\u003c/code\u003e badly formatted JSON.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"getting-a-contact-intersection\"\u003eGetting a contact intersection\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003ePUT /v1/directory/tokens\nAuthorization: Basic {basic_auth}\nX-PKG-NAME: {package_name}\nX-PKG-TOKEN: {package_token}\n\n{\n  \u0026quot;contacts\u0026quot;: [ \u0026quot;{token}\u0026quot;, \u0026quot;{token}\u0026quot;, ..., \u0026quot;{token}\u0026quot; ]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e\u003ccode\u003etoken\u003c/code\u003e is Base64(SHA1(E164number)[0:10]) without Base64 padding.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eReturns\u003c/strong\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e400\u003c/code\u003e badly formatted token(s).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e401\u003c/code\u003e invalid authentication credentials.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e415\u003c/code\u003e badly formatted JSON.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e200\u003c/code\u003e request succeeded. The structure below is returned.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  contacts: [{token=\u0026quot;{token}\u0026quot;, relay=\u0026quot;{relay}\u0026quot;, supportsSms=\u0026quot;true\u0026quot;},\n             {token=\u0026quot;{token}\u0026quot;},\n             ...,\n             {token=\u0026quot;tokenN\u0026quot;, relay=\u0026quot;{relay}\u0026quot;}]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e\u003ccode\u003etoken\u003c/code\u003e is Base64(SHA1(E164number)[0:10]) without Base64 padding.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erelay\u003c/code\u003e is the name of a federated node which this contact is associated with.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esupportsSms\u003c/code\u003e indicates that the contact supports the SMS transport.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAt this point the client should be fully registered.\u003c/p\u003e\n\u003ch3 id=\"sending-messages\"\u003eSending Messages\u003c/h3\u003e\n\u003ch4 id=\"message-format\"\u003eMessage Format\u003c/h4\u003e\n\u003cp\u003eMessages bodies sent and received by clients are a protocol buffer structure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emessage PushMessageContent {\n  message AttachmentPointer {\n    optional fixed64 id          = 1;\n    optional string  contentType = 2;\n    optional bytes   key         = 3;\n  }\n\n  message GroupContext {\n    enum Type {\n      UNKNOWN = 0;\n      UPDATE  = 1;\n      DELIVER = 2;\n      QUIT    = 3;\n    }\n    optional bytes             id      = 1;\n    optional Type              type    = 2;\n    optional string            name    = 3;\n    repeated string            members = 4;\n    optional AttachmentPointer avatar  = 5;\n  }\n\n  enum Flags {\n    END_SESSION = 1;\n  }\n\n  optional string            body        = 1;\n  repeated AttachmentPointer attachments = 2;\n  optional GroupContext      group       = 3;\n  optional Flags             flags       = 4;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"getting-a-recipients-prekey\"\u003eGetting a recipient\u0026rsquo;s PreKey\u003c/h4\u003e\n\u003cp\u003eIf a client does not have an existing session with a recipient, the client will need to retrieve a PreKey for the recipient in order to start one.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGET /v2/keys/{number}/{device_id}?relay={relay}\nAuthorization: Basic {basic_auth}\nX-PKG-NAME: {package_name}\nX-PKG-TOKEN: {package_token}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e\u003ccode\u003enumber\u003c/code\u003e is the number of the recipient.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edevice_id\u003c/code\u003e is the device id of the recipient, or \u003ccode\u003e*\u003c/code\u003e for all devices.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erelay\u003c/code\u003e (optional) is the federated relay the recipient is associated with.  The \u003ccode\u003erelay\u003c/code\u003e param should only be included if the destination is at a federated node other than the sender.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eReturns\u003c/strong\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e401\u003c/code\u003e invalid authentication credentials.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e413\u003c/code\u003e rate limit exceeded.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e404\u003c/code\u003e unknown/unregistered \u003ccode\u003enumber\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e200\u003c/code\u003e request succeeded. The structure below is returned.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026quot;keys\u0026quot; : [\n    {\n      \u0026quot;deviceId\u0026quot;: {device_id},\n      \u0026quot;keyId\u0026quot;: {key_id},\n      \u0026quot;publicKey\u0026quot;: \u0026quot;{public_key}\u0026quot;,\n      \u0026quot;identityKey\u0026quot;: \u0026quot;{public_key}\u0026quot;    \n    },\n    ...\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"submitting-a-message\"\u003eSubmitting a message\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003ePUT /v1/messages/{destination_number}\nAuthorization Basic {basic_auth}\nX-PKG-NAME: {package_name}\nX-PKG-TOKEN: {package_token}\n\n{\n  relay: \u0026quot;{relay}\u0026quot;,\n  messages: [{\n               type: {type},\n               destinationDeviceId: {destination_device_id},\n               destinationRegistrationId: {destination_registration_id},\n               body: \u0026quot;{base64_encoded_message_body}\u0026quot;, // Encrypted PushMessageContent\n               timestamp: \u0026quot;{time_sent_millis_since_epoc}\u0026quot;\n              },\n             ...,\n             ]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e\u003ccode\u003edestination_number\u003c/code\u003e is the PSTN number of the message recipient.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erelay\u003c/code\u003e (optional) is the relay the message recipient is registered with.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etype\u003c/code\u003e is the type of message. Supported types are enumerated below.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edestination_device_id\u003c/code\u003e is the target device the message corresponds to for the \u003ccode\u003edestination_number\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebody\u003c/code\u003e is the Base64 encoded (without padding) and encrypted \u003ccode\u003ePushMessageContent\u003c/code\u003e (above).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etimestamp_sent_millis_since_epoch\u003c/code\u003e is the timestamp of the message in millis since the epoch.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eReturns\u003c/strong\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e401\u003c/code\u003e invalid authentication credentials.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e409\u003c/code\u003e mismatched devices.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e410\u003c/code\u003e stale devices.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e413\u003c/code\u003e rate limit exceeded.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e415\u003c/code\u003e badly formatted JSON.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e200\u003c/code\u003e request succeeded.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e409 Mismatched Devices\u003c/strong\u003e:\u003c/p\u003e\n\u003cp\u003eThis return code indicates that the devices in \u003ccode\u003emessages\u003c/code\u003e do not match the registered devices for \u003ccode\u003edestination_number\u003c/code\u003e.  The response body indicates the mismatch:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  missingDevices: [{missing_device_id}, {another_missing_device_id}, ...],\n  extraDevices: [{device_id_doesnt_exist}, ...]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e410 Stale Devices\u003c/strong\u003e:\u003c/p\u003e\n\u003cp\u003eThis return code indicates that a target device has re-installed and the requesting client is sending a message for a stale session.  The response body indicates which devices are affected:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  staleDevices: [{stale_device_id}, ...]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"receiving-a-message\"\u003eReceiving a message\u003c/h4\u003e\n\u003cp\u003eAPN clients will receive a push notification:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  alert: \u0026quot;You have a new message!\u0026quot;,\n  \u0026quot;m\u0026quot;: \u0026quot;{payload}\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGCM clients will receive a push notification:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{payload}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e\u003ccode\u003epayload\u003c/code\u003e is a Base64 encoded (without padding) \u003ccode\u003eIncomingPushMessageSignal\u003c/code\u003e, which is encrypted and MAC\u0026rsquo;d using the \u003ccode\u003esignalingKey\u003c/code\u003e submitted during registration.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eEncrypted IncomingPushMessageSignal format:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estruct {\n  opaque version[1];\n  opaque iv[16];\n  opaque ciphertext[...]; // The IncomingPushMessageSignal\n  opaque mac[10];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe IncomingPushMessageSignal protocol buffer:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emessage IncomingPushMessageSignal {\n  enum Type {\n    UNKNOWN       = 0;\n    CIPHERTEXT    = 1;\n    KEY_EXCHANGE  = 2;\n    PREKEY_BUNDLE = 3;\n    PLAINTEXT     = 4;\n  }\n  optional Type   type         = 1;\n  optional string source       = 2;\n  optional uint32 sourceDevice = 7;\n  optional string relay        = 3;\n  optional uint64 timestamp    = 5;\n  optional bytes  message      = 6; // Contains an encrypted PushMessageContent\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"attachments\"\u003eAttachments\u003c/h3\u003e\n\u003cp\u003eRecall that a push message is transmitted as the following structure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emessage PushMessageContent {\n  message AttachmentPointer {\n    optional fixed64 id          = 1;\n    optional string  contentType = 2;\n    optional bytes   key         = 3;\n  }\n\n  message GroupContext {\n    enum Type {\n      UNKNOWN = 0;\n      UPDATE  = 1;\n      DELIVER = 2;\n      QUIT    = 3;\n    }\n    optional bytes             id      = 1;\n    optional Type              type    = 2;\n    optional string            name    = 3;\n    repeated string            members = 4;\n    optional AttachmentPointer avatar  = 5;\n  }\n\n  enum Flags {\n    END_SESSION = 1;\n  }\n\n  optional string            body        = 1;\n  repeated AttachmentPointer attachments = 2;\n  optional GroupContext      group       = 3;\n  optional Flags             flags       = 4;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo fill out the \u003ccode\u003eAttachmentPointer\u003c/code\u003e structure, the client takes the following steps:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eGenerates a single-use 32 byte AES key and 32 byte Hmac-SHA256 key.\u003c/li\u003e\n\u003cli\u003eEncrypts the attachment using AES in CBC mode with PKCS#5 padding and a random IV, then formats the encrypted blob as \u003ccode\u003eIV || Ciphertext || MAC\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eRequests an attachment allocation from the server.\u003c/li\u003e\n\u003cli\u003eUploads the attachment to the allocation.\u003c/li\u003e\n\u003cli\u003eConstructs the \u003ccode\u003eAttachmentPointer\u003c/code\u003e with the attachment allocation \u003ccode\u003eid\u003c/code\u003e, the attachment\u0026rsquo;s MIME \u003ccode\u003econtentType\u003c/code\u003e, and the concatenated 32 byte AES and 32 byte Hmac-SHA256 \u003ccode\u003ekey\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"allocating-an-attachment\"\u003eAllocating an attachment\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003eGET /v1/attachments/\nAuthorization: {basic_auth}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eReturns\u003c/strong\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e401\u003c/code\u003e invalid authentication credentials.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e413\u003c/code\u003e rate limit exceeded.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e200\u003c/code\u003e request succeeded. The structure below is returned.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026quot;id\u0026quot; : \u0026quot;{attachment_id}\u0026quot;,\n  \u0026quot;location\u0026quot; : \u0026quot;{attachment_url}\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"uploading-an-attachment\"\u003eUploading an attachment\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003ePUT {attachment_url}\nContent-Type: application/octet-stream\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe client \u003ccode\u003ePUT\u003c/code\u003es the encrypted binary blob to the \u003ccode\u003eattachment_url\u003c/code\u003e returned from the attachment allocation step.\u003c/p\u003e\n\u003ch4 id=\"retrieving-an-attachment\"\u003eRetrieving an attachment\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003eGET /v1/attachments/{attachment_id}\nAuthorization: {basic_auth}\nX-PKG-NAME: {package_name}\nX-PKG-TOKEN: {package_token}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\n\u003cli\u003e\u003ccode\u003eattachment_id\u003c/code\u003e is the \u003ccode\u003eid\u003c/code\u003e in a received \u003ccode\u003eAttachmentPointer\u003c/code\u003e protocol buffer.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eReturns\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e401\u003c/code\u003e invalid authentication credentials.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e413\u003c/code\u003e rate limit exceeded.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e200\u003c/code\u003e request succeeded. The structure below is returned.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026quot;location\u0026quot; : \u0026quot;{attachment_url}\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe client can now \u003ccode\u003eGET {attachment_url}\u003c/code\u003e to retrieve the encrypted binary blob.\u003c/p\u003e\n\u003ch2 id=\"specification-versions\"\u003eSpecification Versions\u003c/h2\u003e\n"},{id:2,href:"https://project-wormhole.github.io/docs/",title:"Specification",description:"Specification Wormhole.",content:""},];index.add(docs);userinput.addEventListener('input',show_results,true);suggestions.addEventListener('click',accept_suggestion,true);function show_results(){var value=this.value;var results=index.search(value,5);var entry,childs=suggestions.childNodes;var i=0,len=results.length;suggestions.classList.remove('d-none');results.forEach(function(page){entry=document.createElement('div');entry.innerHTML='<a href><span></span><span></span></a>';a=entry.querySelector('a'),t=entry.querySelector('span:first-child'),d=entry.querySelector('span:nth-child(2)');a.href=page.href;t.textContent=page.title;d.textContent=page.description;suggestions.appendChild(entry);});while(childs.length>len){suggestions.removeChild(childs[i])}}
function accept_suggestion(){while(suggestions.lastChild){suggestions.removeChild(suggestions.lastChild);}
return false;}}());